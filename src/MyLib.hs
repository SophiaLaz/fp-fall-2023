{-# LANGUAGE BangPatterns #-}

module MyLib where

-------------------------------------------------------------------------------

-- 1. Какие из выражений ниже находятся в слабой головной нормальной форме (WHNF),
--    но не в номальной форме (NF)? Почему? (1,5 балла)

-- Подсказка: выражение undefined находится не в NF:
--            оно может быть вычислено до прерывания программы с сообщением "*** Exception: Prelude.undefined"

    -- (+) (2 * 3 * 4)          -- WHNF, так как крайним конструктором является (+) и он вычислен

    -- [undefined, 4 + 5, -1]   -- WHNF, так как вычислен крайний конструктор (сбор в список)

    -- (,) undefined            -- WHNF, так как крайним конструктором является (,) и он вычислен

    -- 3                        -- NF, так как выражение полностью вычислено

    -- fst (1,0)                -- крайним конструктором здесь является `fst` и он не вычислен
                                -- значит это не нормальная форма, а просто thunk ?

    -- \x -> x                  -- WHNF, так как просто возвращаем x, не обращая внимания на то, какой он

-------------------------------------------------------------------------------

-- 2. Распишите вычисление `value` в thunk'ах (1 балл)

value :: Integer
value = foo (3 * 10) (5 - 2)
  where
    foo :: Num p => p -> p -> p
    foo a b = bar a a (a + b)

    bar :: Num a => a -> a -> p -> a
    bar x y z = x + y

-- <thunk: foo <thunk: (3 * 10)> <thunk: (5 - 2)> >

-- <thunk: <thunk: bar <thunk: (3 * 10)> <thunk: (3 * 10)> <thunk: <thunk: (3 * 10)> + <thunk: (5 - 2)> > >

-- <thunk: bar <thunk: (3 * 10)> <thunk: (3 * 10)> <thunk: <thunk: (3 * 10)> + <thunk: (5 - 2)> >

-- <thunk: <thunk: (3 * 10)> + <thunk: (3 * 10)> > 

-- <thunk:  <thunk: 30 > + <thunk: 30 >  > 

-- <thunk: 30 + 30  > 

-- <thunk: 60  > 

-- 60

-------------------------------------------------------------------------------

-- 3. Какие из нижеперечисленных функций не могут привести к расходимости (неостановке вычисления)? Почему? (2 балла)
-- NB: Я немного запуталась: кажется, что если не требуется вывода на экран, то никакие функции не приводят к расходимости 
--     (потому что тогда её не надо считать). Поэтому все функции рассмотрела с той точки зрения, что все функции приводятся к WHNF.
wow :: p -> p
wow a = a                                   -- не приводит к расходимости, если подать что-то бесконечно вычисляющееся (пример: product [1, 2..])

con :: b -> Integer -> Integer -> Integer
con = const foo                             -- если `foo` - функция, которая определена ниже, то приведёт к расходимости,
                                            -- если подать `con "ignore" (-5) 5` (уйдёт в бесконечную рекурсию)
bazz :: p -> b -> Bool
bazz x = const True                         -- не может привести к расходимости, потому что функция не строгая по `x`
                                            -- при любом входе она вернёт `True`

qux :: t
qux = let x = x in x                        -- может привести к расходимости, так как содержит ссылку на самого себя,
                                            -- а значит зациклится

corge :: String
corge = "Sorry, my value was changed"       -- не может привести к расходимости, так как просто возвращает строку

grault :: (Eq a, Num a) => p -> a -> p
grault x 0 = x
grault x y = x                              -- может привести к расходимости из-за аргумента `x`, аналогично `wow`

garply :: Integer -> Char
garply = grault 'q'                         -- не может привести к расходимости, так как вызывает известную функцию 
                                            -- с конечным аргументом, который и вернётся в качестве результата исходной функции

waldo :: Integer -> Integer -> Integer
waldo = foo                                 -- аналогично функции `con` - приведёт к расходимости, если первый аргумент отрицательный
                                            -- (бесконечная рекурсия)

-------------------------------------------------------------------------------

-- 4. BangPatterns  (0,5 балла)
--    Реализуйте `foldl'`, форсировав вычисление с помощью ! аналогично `sumBang` из лекции

myFoldl' :: (b -> a -> b) -> b -> [a] -> b
myFoldl' _  ini []      = ini
myFoldl' f !ini (!x:xs) = myFoldl' f (f ini x) xs

-- myFoldl' (\ acc x -> (x + 1) : acc) [] [1, 2, 3, 4] == [5, 4, 3, 2]
-------------------------------------------------------------------------------

-- 5. `seq` (2 балла)

-- Помимо ! есть и другие способы форсировать вычисление.
-- Например, если вы хотите вычислить значение перед передачей его в функцию, можно использовать `seq` 
-- https://hackage.haskell.org/package/ghc-prim-0.11.0/docs/GHC-Prim.html#v:seq

-- `seq` принимает 2 аргумента, вычисляет первый до WHNF и возвращает второй

-- Как использовать? Пример с foldl':
-- https://hackage.haskell.org/package/base-4.19.0.0/docs/src/Data.Foldable.html#foldl%27
-- Здесь есть следующий код: z `seq` k (f z x).
-- В этом случае первый аргумент `seq` -- z, и z будет вычислено до WHNF,
-- а затем он будет использоватся при вычислении второго аргумента -- k (f z x).
-- Результат вычисления второго аргумента -- результат всего `seq`

-- Практикуемся: где поможет seq?
-- При вычислении каких из перечисленных ниже функций использование seq предотвратит
-- нарастание количества невычисленных выражений при увеличении значения первого аргумента?
-- Объясните свой ответ

foo :: (Eq a, Num a, Num t) => a -> t -> t              -- Тут `seq` не помогает, потому что мы форсируем рекурсивные вычисления
foo 0 x = x                                             -- т.е. чтобы вернуть результат `foo (n - 1) (x + 1)`, мы должны спуститься 
foo n x = let x' = foo (n - 1) (x + 1)                  -- до 1-го случая паттерн-матчинга (или на бесконечность, если `n < 0`),
          in x' `seq` x'                                -- причём мы вычисляем аргумент до WHNF, а значит будет вычислен внешний конструктор `foo`,
                                                        -- а вычисления для `x` будут накапливаться.

bar :: (Eq t1, Num t1) => t1 -> (t1 -> t2) -> t1 -> t2  -- Помогает для `x`, бесполезен для `f`. Запишем без `seq`: 
bar 0 f v  = f  v                                       -- bar' x f = \a -> bar (x - 1) f (x + a) 
bar x f v = let f' = \a -> f (x + a)                    -- Для `f'` не помогает, так как вычисления идут до внешнего конструктора `f`,
                x' = x - 1                              -- а значит будут накапливаться. Для `x'` вычисления форсируются, накопления не будет.
            in f' `seq` x' `seq` bar x' f' v            

baz :: (Eq t, Num t, Num a) => t -> (a, a) -> a         -- Тут не помогает для `p`, потому что мы форсируем вычисления `p` до WHNF,
baz 0 (x, y) = x + y                                    -- а значит до сбора конструктора (x + 1, y - 1). Вычисления внутри `p`
baz n (x, y) = let x' = x + 1                           -- будут накапливаться. 
                   y' = y - 1                           -- А для `n'` тоже не нужно, потому что при каждом рекурсивном спуске 
                   p  = (x', y')                        -- нам всё равно надо посчитать `n`, так как его надо сравнить с 0,
                   n' = n - 1                           -- а значит `n` будет вычисляться сам, без форсирования.
               in p `seq` n' `seq` baz n' p

quux :: (Eq t, Num t, Num a) => t -> (a, a) -> a        -- Помогает для `x', y'`. Теперь в кортеже не будет происходить накоплений вычислений.
quux 0 (x, y) = x + y                                   -- Для `n` аналогично предыдущему примеру - бесполезное форсирование 
quux n (x, y) = let x' = x + 1                          -- из-за условий паттерн-матчинга.
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p

-------------------------------------------------------------------------------

-- 6. $! (1 балл)

-- Вдобавок к ! и `seq` есть $!. Он нужен, чтобы вычислить значение перед передачей его в функцию.
-- Несложно заметить, что он напоминает $ -- оператор применения.
-- $! -- строгую версию $, вычисляющую аргумент до WHNF перед передачей его в функцию

-- Ниже определены функции mySum и goSum. Ответьте на вопросы об их вычислении

mySum :: (Eq a, Num a) => (a, ()) -> a -> (a, ())
mySum acc 0 = acc
-- 6.a Почему Haskell говорит здесь, что $! -- redundant?

-- Потому что вычисляется до WHNF, а значит соберётся кортеж, а операция сложения не будет вычислена -> оптимизации нет 
-- mySum (result, ()) n = (mySum $! (result + n, ())) $ n - 1

-- Я думаю, чтобы сумма форсированно вычислилась, надо записать так:
mySum (result, ()) n = (mySum $! let !x' = result + n in (x', ())) $ n - 1


goSum :: Integer -> (Integer, ())
goSum = mySum (0, ())


-- 6.b Будут ли накапливаться отложенные вычисления в первом аргументе функции mySum?
--    Да или нет и почему?

-- Да, будут. Потому что мы форсируем создание кортежа, но не вычисление значения, лежащего в нём, 
-- а значит эти операции будут накапливаться.


-- 6.c Будут ли накапливаться отложенные вычисления во втором аргументе функции mySum?
--    Да или нет и почему?

-- Нет, не будут, так как при кажждом рекурсивном вызове функции `mySum` компилятор должен знать, чему в точности 
-- равно `n` из-за условий паттерн-матчинга. А значит при каждом вызове фукнции `n - 1` будет вычислено.

-------------------------------------------------------------------------------

-- 7*. Почему здесь происходит утечка памяти? Как ее исправить? (2 балла)

-- let small' = fst (small, large) in ... small' ...

-- Утечка памяти означает, что программа выделяет больше памяти, чем необходимо для ее выполнения. 
-- В случае отложенных вычислений это приводит к накоплению thunk'ов, которые потребляют тем больше памяти,
-- чем болше вычислений им надо сделать. 

-- Конкретно в данном случае она происходит из-за сохранения ненужной ссылки (на `large`).
-- Согласно wiki [ https://wiki.haskell.org/Memory_leak ] до тех пор, пока мы не вычислим `small'`, ссылки на
-- `small` и `large` остаются активными. После его вычисления `large` может быть собран как "мусор" (если
-- на него нет ссылок в другом месте кода). 


-- В даннной ситуации есть два пути оптимизации:
-- 1.  Убрать ненужное переопределение переменных `small -> small'`, так как в дальнейшей части кода `large` не используется.
-- 2.  Не накапливать вычисления `large`, а форсировать их (если когда-то он нам всё же может пригодиться) -> это позволит
--     сильно уменьшить количество потребляемой памяти.

-- ну и можно попробовать третий способ -- я про него читала, но пока не тестировала))
-- 3.* Установить следующий флаг в сборочном файле .cabal: 
--     ghc-options:     -O2
--     Это стандартный для компилятора Haskell уровень оптимизации: это значит, что он может найти излишнюю ленивость
--     в нашем коде и немного пофорсировать вычисления.

-------------------------------------------------------------------------------
